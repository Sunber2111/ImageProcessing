{"ast":null,"code":"// Copyright 2014 Andrei Karpushonak\n'use strict';\n\nvar ECMA_SIZES = require('./byte_size');\n\nvar Buffer = require('buffer').Buffer;\n\nfunction sizeOfObject(seen, object) {\n  if (object == null) {\n    return 0;\n  }\n\n  var bytes = 0;\n\n  for (var key in object) {\n    // Do not recalculate circular references\n    if (typeof object[key] === 'object' && object[key] !== null) {\n      if (seen.has(object[key])) {\n        continue;\n      }\n\n      seen.add(object[key]);\n    }\n\n    bytes += getCalculator(seen)(key);\n\n    try {\n      bytes += getCalculator(seen)(object[key]);\n    } catch (ex) {\n      if (ex instanceof RangeError) {\n        // circular reference detected, final result might be incorrect\n        // let's be nice and not throw an exception\n        bytes = 0;\n      }\n    }\n  }\n\n  return bytes;\n}\n\nfunction getCalculator(seen) {\n  return function (object) {\n    if (Buffer.isBuffer(object)) {\n      return object.length;\n    }\n\n    var objectType = typeof object;\n\n    switch (objectType) {\n      case 'string':\n        return object.length * ECMA_SIZES.STRING;\n\n      case 'boolean':\n        return ECMA_SIZES.BOOLEAN;\n\n      case 'number':\n        return ECMA_SIZES.NUMBER;\n\n      case 'object':\n        if (Array.isArray(object)) {\n          return object.map(getCalculator(seen)).reduce(function (acc, curr) {\n            return acc + curr;\n          }, 0);\n        } else {\n          return sizeOfObject(seen, object);\n        }\n\n      default:\n        return 0;\n    }\n  };\n}\n/**\n * Main module's entry point\n * Calculates Bytes for the provided parameter\n * @param object - handles object/string/boolean/buffer\n * @returns {*}\n */\n\n\nfunction sizeof(object) {\n  return getCalculator(new WeakSet())(object);\n}\n\nmodule.exports = sizeof;","map":{"version":3,"sources":["D:/XLA/project/node_modules/object-sizeof/index.js"],"names":["ECMA_SIZES","require","Buffer","sizeOfObject","seen","object","bytes","key","has","add","getCalculator","ex","RangeError","isBuffer","length","objectType","STRING","BOOLEAN","NUMBER","Array","isArray","map","reduce","acc","curr","sizeof","WeakSet","module","exports"],"mappings":"AAAA;AAEA;;AAEA,IAAIA,UAAU,GAAGC,OAAO,CAAC,aAAD,CAAxB;;AACA,IAAIC,MAAM,GAAGD,OAAO,CAAC,QAAD,CAAP,CAAkBC,MAA/B;;AAEA,SAASC,YAAT,CAAuBC,IAAvB,EAA6BC,MAA7B,EAAqC;AACnC,MAAIA,MAAM,IAAI,IAAd,EAAoB;AAClB,WAAO,CAAP;AACD;;AAED,MAAIC,KAAK,GAAG,CAAZ;;AACA,OAAK,IAAIC,GAAT,IAAgBF,MAAhB,EAAwB;AACtB;AACA,QAAI,OAAOA,MAAM,CAACE,GAAD,CAAb,KAAuB,QAAvB,IAAmCF,MAAM,CAACE,GAAD,CAAN,KAAgB,IAAvD,EAA6D;AAC3D,UAAIH,IAAI,CAACI,GAAL,CAASH,MAAM,CAACE,GAAD,CAAf,CAAJ,EAA2B;AACzB;AACD;;AACDH,MAAAA,IAAI,CAACK,GAAL,CAASJ,MAAM,CAACE,GAAD,CAAf;AACD;;AAEDD,IAAAA,KAAK,IAAII,aAAa,CAACN,IAAD,CAAb,CAAoBG,GAApB,CAAT;;AACA,QAAI;AACFD,MAAAA,KAAK,IAAII,aAAa,CAACN,IAAD,CAAb,CAAoBC,MAAM,CAACE,GAAD,CAA1B,CAAT;AACD,KAFD,CAEE,OAAOI,EAAP,EAAW;AACX,UAAIA,EAAE,YAAYC,UAAlB,EAA8B;AAC5B;AACA;AACAN,QAAAA,KAAK,GAAG,CAAR;AACD;AACF;AACF;;AAED,SAAOA,KAAP;AACD;;AAED,SAASI,aAAT,CAAwBN,IAAxB,EAA8B;AAC5B,SAAO,UAAUC,MAAV,EAAkB;AACvB,QAAIH,MAAM,CAACW,QAAP,CAAgBR,MAAhB,CAAJ,EAA6B;AAC3B,aAAOA,MAAM,CAACS,MAAd;AACD;;AAED,QAAIC,UAAU,GAAG,OAAQV,MAAzB;;AACA,YAAQU,UAAR;AACE,WAAK,QAAL;AACE,eAAOV,MAAM,CAACS,MAAP,GAAgBd,UAAU,CAACgB,MAAlC;;AACF,WAAK,SAAL;AACE,eAAOhB,UAAU,CAACiB,OAAlB;;AACF,WAAK,QAAL;AACE,eAAOjB,UAAU,CAACkB,MAAlB;;AACF,WAAK,QAAL;AACE,YAAIC,KAAK,CAACC,OAAN,CAAcf,MAAd,CAAJ,EAA2B;AACzB,iBAAOA,MAAM,CAACgB,GAAP,CAAWX,aAAa,CAACN,IAAD,CAAxB,EAAgCkB,MAAhC,CAAuC,UAAUC,GAAV,EAAeC,IAAf,EAAqB;AACjE,mBAAOD,GAAG,GAAGC,IAAb;AACD,WAFM,EAEJ,CAFI,CAAP;AAGD,SAJD,MAIO;AACL,iBAAOrB,YAAY,CAACC,IAAD,EAAOC,MAAP,CAAnB;AACD;;AACH;AACE,eAAO,CAAP;AAhBJ;AAkBD,GAxBD;AAyBD;AAED;;;;;;;;AAMA,SAASoB,MAAT,CAAiBpB,MAAjB,EAAyB;AACvB,SAAOK,aAAa,CAAC,IAAIgB,OAAJ,EAAD,CAAb,CAA6BrB,MAA7B,CAAP;AACD;;AAEDsB,MAAM,CAACC,OAAP,GAAiBH,MAAjB","sourcesContent":["// Copyright 2014 Andrei Karpushonak\n\n'use strict'\n\nvar ECMA_SIZES = require('./byte_size')\nvar Buffer = require('buffer').Buffer\n\nfunction sizeOfObject (seen, object) {\n  if (object == null) {\n    return 0\n  }\n\n  var bytes = 0\n  for (var key in object) {\n    // Do not recalculate circular references\n    if (typeof object[key] === 'object' && object[key] !== null) {\n      if (seen.has(object[key])) {\n        continue\n      }\n      seen.add(object[key])\n    }\n\n    bytes += getCalculator(seen)(key)\n    try {\n      bytes += getCalculator(seen)(object[key])\n    } catch (ex) {\n      if (ex instanceof RangeError) {\n        // circular reference detected, final result might be incorrect\n        // let's be nice and not throw an exception\n        bytes = 0\n      }\n    }\n  }\n\n  return bytes\n}\n\nfunction getCalculator (seen) {\n  return function (object) {\n    if (Buffer.isBuffer(object)) {\n      return object.length\n    }\n\n    var objectType = typeof (object)\n    switch (objectType) {\n      case 'string':\n        return object.length * ECMA_SIZES.STRING\n      case 'boolean':\n        return ECMA_SIZES.BOOLEAN\n      case 'number':\n        return ECMA_SIZES.NUMBER\n      case 'object':\n        if (Array.isArray(object)) {\n          return object.map(getCalculator(seen)).reduce(function (acc, curr) {\n            return acc + curr\n          }, 0)\n        } else {\n          return sizeOfObject(seen, object)\n        }\n      default:\n        return 0\n    }\n  }\n}\n\n/**\n * Main module's entry point\n * Calculates Bytes for the provided parameter\n * @param object - handles object/string/boolean/buffer\n * @returns {*}\n */\nfunction sizeof (object) {\n  return getCalculator(new WeakSet())(object)\n}\n\nmodule.exports = sizeof\n"]},"metadata":{},"sourceType":"script"}